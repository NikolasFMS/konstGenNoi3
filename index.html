<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —à—É–º–∞</title>
  <script async src="https://docs.opencv.org/4.5.5/opencv.js" onload="onOpenCvReady()"></script>
  <style>
    :root {
      --bg-color: #222;
      --card-bg: #333;
      --text-color: #ffffff;
      --accent-color: #1465ac;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      --border-radius: 12px;
    }

    body {
      background: var(--bg-color);
      color: var(--text-color);
      font-family: -apple-system, BlinkMacSystemFont, 'system-ui', sans-serif;
      margin: 0;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow-y: auto;
      box-sizing: border-box;
    }

    .container {
      max-width: 1200px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 16px;
      max-height: 100vh;
      box-sizing: border-box;
    }

    .canvas-container {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
    }

    canvas {
      border: 1px solid #555;
      border-radius: var(--border-radius);
      max-height: calc(100vh - 320px);
      width: 100%;
      object-fit: contain;
      background: #000;
      box-shadow: var(--shadow);
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      padding: 12px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
      position: relative;
    }

    label {
      font-size: 14px;
      font-weight: 500;
      opacity: 0.9;
    }

    input[type="number"],
    select,
    input[type="checkbox"],
    input[type="color"] {
      background: #666;
      border: none;
      border-radius: 8px;
      padding: 8px;
      color: var(--text-color);
      font-size: 14px;
      transition: background 0.2s;
      width: 100%;
      box-sizing: border-box;
    }

    input[type="number"]:hover,
    select:hover,
    input[type="color"]:hover {
      background: #4a545c;
    }

    button {
      background: var(--accent-color);
      border: none;
      border-radius: 7px;
      padding: 10px 16px;
      color: white;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: transform 0.1s, background 0.2s;
      box-shadow: var(--shadow);
    }

    button:hover {
      background: #082f51;
      transform: scale(1.04);
    }

    button:active {
      transform: scale(0.95);
    }

    .actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
      padding: 12px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
    }

    .layers {
      padding: 12px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
    }

    .layer-item {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      padding: 8px;
      border-bottom: 1px solid #555;
    }

    #progress,
    #metrics,
    #recommendations {
      font-size: 14px;
      padding: 12px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      text-align: center;
      box-shadow: var(--shadow);
    }

    #progress {
      display: none;
      background-color: #D12525;
    }

    #metrics,
    #recommendations {
      display: block;
      font-size: 13px;
      opacity: 0.9;
    }

    #recommendations {
      text-align: left;
    }

    .tooltip {
      visibility: hidden;
      background: #000;
      color: white;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      white-space: nowrap;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .control-group:hover .tooltip {
      visibility: visible;
      opacity: 1;
    }

    @media (max-width: 600px) {

      .controls,
      .layer-item {
        grid-template-columns: 1fr;
      }

      canvas {
        max-height: calc(100vh - 400px);
      }
    }

    /* –°—Ç–∏–ª–∏ –¥–ª—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
    }

    .modal-content {
      background-color: #2e2e2e;
      margin: 5% auto;
      padding: 15px;
      border-radius: 12px;
      width: 80%;
      max-width: 1900px;
      color: white;
      font-family: sans-serif;
      box-shadow: 0 0 15px black;
      animation: fadeIn 0.3s ease-out;
    }

    .close {
      float: right;
      font-size: 28px;
      cursor: pointer;
    }

    .preset-list {
      padding: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
      max-height: 400px;
      overflow-y: auto;
      padding-right: 10px;
    }

    /* –°—Ç–∏–ª–∏–∑–∞—Ü–∏—è —Å–∫—Ä–æ–ª–ª–±–∞—Ä–∞ */
    #presetList::-webkit-scrollbar {
      width: 8px;
      /* –®–∏—Ä–∏–Ω–∞ —Å–∫—Ä–æ–ª–ª–±–∞—Ä–∞ */
    }

    #presetList::-webkit-scrollbar-thumb {
      background-color: #1465ac;
      /* –¶–≤–µ—Ç –±–µ–≥—É–Ω–∫–∞ */
      border-radius: 2px;
      /* –ó–∞–∫—Ä—É–≥–ª–µ–Ω–∏–µ —É–≥–ª–æ–≤ */
      border: 2px solid #fff;
    }

    #presetList::-webkit-scrollbar-track {
      background-color: #f1f1f1;
      border-radius: 4px;
    }

    /* –î–ª—è Firefox */
    #presetList {
      scrollbar-width: thin;
      scrollbar-color: #1465ac #0e0e0e;
    }

    .preset-card {
      background: #444;
      border-radius: 8px;
      padding: 10px;
      width: 150px;
      text-align: center;
      box-shadow: 0 0 5px black;
    }

    .preset-card button {
      margin-top: 5px;
      width: 100%;
      padding: 4px;
      border: none;
      cursor: pointer;
    }

    .preset-card button.load {
      background-color: #39ba7b;
      color: white;
    }

    .preset-card button.delete {
      background-color: #c34034;
      color: white;

    }

    #presetNameInput {
      padding: 10px;
      border-radius: 5px;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</head>

<body>
  <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ -->
  <div id="presetModal" class="modal">
    <div class="modal-content">
      <span id="closeModal" class="close">&times;</span>
      <h2>üéõ –ú–µ–Ω—é –ø—Ä–µ—Å–µ—Ç–æ–≤</h2>

      <div class="save-section">
        <h3>üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–æ–≤—ã–π –ø—Ä–µ—Å–µ—Ç</h3>
        <input type="text" id="presetNameInput" placeholder="–ò–º—è –ø—Ä–µ—Å–µ—Ç–∞" />
        <button id="savePresetButton">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
      </div>

      <div class="load-section">
        <h3>üìö –ó–∞–≥—Ä—É–∑–∏—Ç—å/–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ—Å–µ—Ç</h3>
        <button id="defaultPreset" onclick="initializePresets()">–í–µ—Ä–Ω—É—Ç—å –±–∞–∑–æ–≤—ã–µ –ø—Ä–µ—Å–µ—Ç—ã</button>

        <div id="presetList" class="preset-list"></div>
      </div>
    </div>
  </div>

  <div class="container">
    <div>
      <label for="imageUpload">–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ:</label>
      <input type="file" id="imageUpload" accept="image/*">
      <button onclick="toggleAnalysis()">–í–∫–ª/–í—ã–∫–ª –∞–Ω–∞–ª–∏–∑</button>
    </div>
    <button id="openPresetModalButton">–ú–µ–Ω—é –ø—Ä–µ—Å–µ—Ç–æ–≤</button>
    <div id="metrics">SSIM: -, PSNR: -, RMSE: -, MAE: -, Entropy: -</div>

    <div class="layers">
      <button onclick="addLayer()">–î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–π</button>
      <div id="layerList"></div>
    </div>

    <div id="progress">–û–±—Ä–∞–±–æ—Ç–∫–∞: 0%</div>
    <div id="progress">–ò—Ç–µ—Ä–∞—Ü–∏—è: <span id="attempt">0</span></div>

    <div class="canvas-container">
      <canvas id="noiseCanvas"></canvas>
    </div>

    <div id="recommendations">–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏: -</div>

    <div class="actions">
      <button onclick="generateNoise()">üé≤ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
      <button onclick="download()">üíæ –°–∫–∞—á–∞—Ç—å</button>
      <button onclick="saveCopies()">üìÅ –°–∫–∞—á–∞—Ç—å <span id="copiesDisplay">5</span> –∫–æ–ø–∏–π:</button>
      <input type="number" id="copies" value="5" min="1" style="width: 60px;" />
      <button onclick="undo()">‚Ü©Ô∏è –û—Ç–º–µ–Ω–∏—Ç—å</button>
      <button onclick="redo()">‚Ü™Ô∏è –í–µ—Ä–Ω—É—Ç—å</button>
    </div>

    <div class="controls">
      <div class="control-group">
        <label>–®–∏—Ä–∏–Ω–∞</label>
        <input type="number" id="width" value="512" min="1" />
        <span class="tooltip">–®–∏—Ä–∏–Ω–∞ —à—É–º–∞ –≤ –ø–∏–∫—Å–µ–ª—è—Ö</span>
      </div>
      <div class="control-group">
        <label>–í—ã—Å–æ—Ç–∞</label>
        <input type="number" id="height" value="1024" min="1" />
        <span class="tooltip">–í—ã—Å–æ—Ç–∞ —à—É–º–∞ –≤ –ø–∏–∫—Å–µ–ª—è—Ö</span>
      </div>
      <div class="control-group">
        <label>–¶–≤–µ—Ç —à—É–º–∞</label>
        <input type="color" id="colorPalette" value="#ffffff" />
        <span class="tooltip">–û—Å–Ω–æ–≤–Ω–æ–π —Ü–≤–µ—Ç –¥–ª—è —Ü–≤–µ—Ç–Ω–æ–≥–æ —à—É–º–∞</span>
      </div>
    </div>
  </div>


  <script>
    const canvas = document.getElementById('noiseCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const progress = document.getElementById('progress');
    const metricsDiv = document.getElementById('metrics');
    const recommendationsDiv = document.getElementById('recommendations');
    const copiesInput = document.getElementById('copies');
    const copiesDisplay = document.getElementById('copiesDisplay');
    let history = [];
    let historyIndex = -1;
    let layers = [{
      id: Date.now(),
      noiseType: 'perlin',
      weight: 0.2,
      noiseLevel: 0.7,
      noiseScale: 50,
      smoothType: 'gaussian',
      smoothValue: 0,
      spots: 10,
      colorNoise: false,
      alphaLevel: 1
    }];

    // Web Worker
    const noiseWorker = new Worker('worker.js'); // –ü–æ–¥–∫–ª—é—á–∞–µ–º –≤–Ω–µ—à–Ω–∏–π Worker

    // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    let originalImageData = null;
    let width = 512;
    let height = 1024;
    let colorPalette = '#ffffff';
    let useAnalysis = true;
    let isProcessing = false; // –§–ª–∞–≥ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –¥—É–±–ª–∏—Ä—É—é—â–∏—Ö—Å—è –≤—ã–∑–æ–≤–æ–≤
    let lastResize = 0;

    function resizeCanvas(width, height) {
      canvas.width = Math.max(1, width);
      canvas.height = Math.max(1, height);
    }

    function calculateMetrics(imgData, width, height, refData = null) {
      const reference = refData || new ImageData(width, height);
      let mse = 0, mae = 0, ssim = 0, entropy = 0, ae = 0, ncc = 0;
      let mean1 = 0, mean2 = 0, var1 = 0, var2 = 0, cov = 0;
      const c1 = 0.01 * 255 * 255, c2 = 0.03 * 255 * 255;
      const histogram = new Array(256).fill(0);
      let sumDiff = 0, sum1 = 0, sum2 = 0, sum1squared = 0, sum2squared = 0, sumProduct = 0;

      for (let i = 0; i < width * height * 4; i += 4) {
        const v1 = (imgData.data[i] + imgData.data[i + 1] + imgData.data[i + 2]) / 3;
        const v2 = (reference.data[i] + reference.data[i + 1] + reference.data[i + 2]) / 3;
        const diff = v1 - v2;
        mse += diff * diff;
        mae += Math.abs(diff);
        sumDiff += diff;
        mean1 += v1;
        mean2 += v2;
        sum1 += v1;
        sum2 += v2;
        sum1squared += v1 * v1;
        sum2squared += v2 * v2;
        sumProduct += v1 * v2;
        histogram[Math.floor(v1)]++;
      }

      const totalPixels = width * height;
      mse /= totalPixels;
      mae /= totalPixels;
      mean1 /= totalPixels;
      mean2 /= totalPixels;
      ae = sumDiff / totalPixels;

      ncc = (sumProduct - sum1 * sum2 / totalPixels) /
        Math.sqrt((sum1squared - sum1 * sum1 / totalPixels) * (sum2squared - sum2 * sum2 / totalPixels)) || 0;

      for (let i = 0; i < width * height * 4; i += 4) {
        const v1 = (imgData.data[i] + imgData.data[i + 1] + imgData.data[i + 2]) / 3;
        const v2 = (reference.data[i] + reference.data[i + 1] + reference.data[i + 2]) / 3;
        var1 += (v1 - mean1) ** 2;
        var2 += (v2 - mean2) ** 2;
        cov += (v1 - mean1) * (v2 - mean2);
      }

      var1 /= totalPixels;
      var2 /= totalPixels;
      cov /= totalPixels;

      ssim = ((2 * mean1 * mean2 + c1) * (2 * cov + c2)) / ((mean1 ** 2 + mean2 ** 2 + c1) * (var1 + var2 + c2));
      const psnr = 10 * Math.log10((255 * 255) / (mse || 1));
      const rmse = Math.sqrt(mse);

      for (let i = 0; i < 256; i++) {
        if (histogram[i] > 0) {
          const p = histogram[i] / totalPixels;
          entropy -= p * Math.log2(p);
        }
      }

      return { ssim: ssim * 100, psnr, rmse, mae, entropy, ae, ncc: ncc * 100 };
    }

    function updateRecommendations(metrics, attempts) {
      const recs = [];

      if (metrics.ssim > 50) {
        recs.push("SSIM –≤—ã—à–µ 50%. –£–≤–µ–ª–∏—á—å—Ç–µ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —à—É–º–∞ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ '–°–æ–ª–ª—å-–ü–µ—Ä–µ—Ü', '–ò–∫—Ä—ã' –∏–ª–∏ '–ò–º–ø—É–ª—å—Å—Å' –¥–ª—è –±–æ–ª—å—à–µ–π —Å–ª—É—á–∞–π–Ω–æ—Å—Ç–∏.");
      } else if (metrics.ssim < 30) {
        recs.push("SSIM –Ω–∏–∂–µ 30% ‚Äî —Ö–æ—Ä–æ—à–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –Ω–∏–∑–∫–æ–π —Å—Ö–æ–∂–µ—Å—Ç–∏.");
      }

      if (metrics.ncc > 50) {
        recs.push("NCC –≤—ã—à–µ 50%. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –±–æ–ª—å—à–µ —Å–ª–æ—ë–≤ —Å —Ö–∞–æ—Ç–∏—á–Ω—ã–º —à—É–º–æ–º (–Ω–∞–ø—Ä–∏–º–µ—Ä, '–ë–µ–ª—ã–π' –∏–ª–∏ '–ì–∞—É—Å–∞').");
      } else if (metrics.ncc < 30) {
        recs.push("NCC –Ω–∏–∂–µ 30% ‚Äî –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è –º–∏–Ω–∏–º–∞–ª—å–Ω–∞, —á—Ç–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ü–µ–ª–∏.");
      }

      if (metrics.psnr > 30) {
        recs.push("PSNR –≤—ã—à–µ 30 –¥–ë ‚Äî –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤—Å—ë –µ—â—ë –±–ª–∏–∑–∫–æ –∫ –æ—Ä–∏–≥–∏–Ω–∞–ª—É. –£–≤–µ–ª–∏—á—å—Ç–µ –≤–µ—Å —Å–ª–æ—è –∏–ª–∏ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —à—É–º–∞.");
      }

      if (metrics.rmse < 20) {
        recs.push("RMSE –Ω–∏–∂–µ 20 ‚Äî —à—É–º —Å–ª–∞–±—ã–π. –£–≤–µ–ª–∏—á—å—Ç–µ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –∏–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–µ —Ç–∏–ø—ã —à—É–º–∞.");
      }

      if (metrics.mae < 10) {
        recs.push("MAE –Ω–∏–∂–µ 10 ‚Äî –∏–∑–º–µ–Ω–µ–Ω–∏—è –º–∏–Ω–∏–º–∞–ª—å–Ω—ã. –£–≤–µ–ª–∏—á—å—Ç–µ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –∏–ª–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—è—Ç–µ–Ω.");
      }

      if (attempts >= 5) {
        recs.push("–î–æ—Å—Ç–∏–≥–Ω—É—Ç–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —É–≤–µ–ª–∏—á–∏—Ç—å noiseLevel –∏–ª–∏ –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π —Å–ª–æ–π —Å —Ç–∏–ø–æ–º 'saltPepper'.");
      }

      recommendationsDiv.innerHTML = recs.length
        ? `–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:<br>‚Ä¢ ${recs.join('<br>‚Ä¢ ')}`
        : '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã –¥–ª—è SSIM –∏ NCC < 50%.';
    }

    function addLayer() {
      const newLayer = {
        id: Date.now(),
        noiseType: 'perlin',
        weight: 0.5,
        noiseLevel: 0.7,
        noiseScale: 10,
        smoothType: 'gaussian',
        smoothValue: 0,
        spots: 50,
        colorNoise: false,
        alphaLevel: 1
      };
      layers.push(newLayer);
      updateLayerUI();
      saveToHistory();
      generateNoise();
    }

    function removeLayer(id) {
      layers = layers.filter(layer => layer.id !== id);
      updateLayerUI();
      generateNoise();
      saveToHistory();
    }

    function updateSmoothInputAttributes(layerId, smoothType) {
      const input = document.querySelector(`#smoothValue-${layerId}`);
      const tooltip = input.parentElement.querySelector('.tooltip');
      if (smoothType === 'gaussian') {
        input.min = 0;
        input.max = 10;
        input.step = 0.1;
        tooltip.textContent = '–†–∞–¥–∏—É—Å –≥–∞—É—Å—Å–æ–≤–∞ —Ä–∞–∑–º—ã—Ç–∏—è (0‚Äì10)';
      } else if (smoothType === 'median') {
        input.min = 0;
        input.max = 5;
        input.step = 1;
        tooltip.textContent = '–†–∞–¥–∏—É—Å –º–µ–¥–∏–∞–Ω–Ω–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞ (0‚Äì5)';
      } else if (smoothType === 'bilateral') {
        input.min = 0;
        input.max = 5;
        input.step = 0.1;
        tooltip.textContent = '–°–∏–≥–º–∞ –±–∏–ª–∞—Ç–µ—Ä–∞–ª—å–Ω–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞ (0‚Äì5)';
      } else if (smoothType === 'anisotropic') {
        input.min = 0;
        input.max = 10;
        input.step = 0.1;
        tooltip.textContent = '–°–∏–ª–∞ –∞–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–æ–≥–æ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è (0‚Äì10)';
      } else if (smoothType === 'nonlocal') {
        input.min = 0;
        input.max = 5;
        input.step = 0.1;
        tooltip.textContent = '–°–∏–ª–∞ –Ω–µ–ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è (0‚Äì5)';
      } else if (smoothType === 'mean') {
        input.min = 0;
        input.max = 5;
        input.step = 1;
        tooltip.textContent = '–†–∞–¥–∏—É—Å —É—Å—Ä–µ–¥–Ω—è—é—â–µ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞ (0‚Äì5)';
      }
    }

    function updateLayerUI() {
      const layerList = document.getElementById('layerList');
      layerList.innerHTML = '';
      layers.forEach(layer => {
        const div = document.createElement('div');
        div.className = 'layer-item';
        div.innerHTML = `
          <div class="control-group">
            <label>–¢–∏–ø —à—É–º–∞</label>
           <select onchange="updateLayer(${layer.id}, 'noiseType', this.value)">
            <option value="perlin" ${layer.noiseType === 'perlin' ? 'selected' : ''}>–ü–µ—Ä–ª–∏–Ω–æ–≤—ã–π</option>
            <option value="simplex" ${layer.noiseType === 'simplex' ? 'selected' : ''}>–°–∏–º–ø–ª–µ–∫—Å–∞</option>
            <option value="fractal" ${layer.noiseType === 'fractal' ? 'selected' : ''}>–§—Ä–∞–∫—Ç–∞–ª—å–Ω—ã–π</option>
            <option value="cellular" ${layer.noiseType === 'cellular' ? 'selected' : ''}>–ö–ª–µ—Ç–æ—á–Ω—ã–π</option>
            <option value="worley" ${layer.noiseType === 'worley' ? 'selected' : ''}>–í–æ—Ä–ª–∏</option>
            <option value="voronoi" ${layer.noiseType === 'voronoi' ? 'selected' : ''}>–í–æ—Ä–æ–Ω–æ–π</option>
            <option value="billow" ${layer.noiseType === 'billow' ? 'selected' : ''}>–ë–∏–ª–ª–æ—É</option>
            <option value="ridged" ${layer.noiseType === 'ridged' ? 'selected' : ''}>–†–∏–¥–∂–µ–¥</option>
            <option value="white" ${layer.noiseType === 'white' ? 'selected' : ''}>–ë–µ–ª—ã–π</option>
            <option value="pink" ${layer.noiseType === 'pink' ? 'selected' : ''}>–†–æ–∑–æ–≤—ã–π</option>
            <option value="brown" ${layer.noiseType === 'brown' ? 'selected' : ''}>–ö–æ—Ä–∏—á–Ω–µ–≤—ã–π</option>
            <option value="blue" ${layer.noiseType === 'blue' ? 'selected' : ''}>–°–∏–Ω–∏–π</option>
            <option value="saltPepper" ${layer.noiseType === 'saltPepper' ? 'selected' : ''}>–°–æ–ª—å-–ø–µ—Ä–µ—Ü</option>
            <option value="gaussian" ${layer.noiseType === 'gaussian' ? 'selected' : ''}>–ì–∞—É—Å—Å–æ–≤</option>
            <option value="gradient" ${layer.noiseType === 'gradient' ? 'selected' : ''}>–ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π</option>
            <option value="sparkle" ${layer.noiseType === 'sparkle' ? 'selected' : ''}>–ò—Å–∫—Ä—ã</option>
            <option value="impulse" ${layer.noiseType === 'impulse' ? 'selected' : ''}>–ò–º–ø—É–ª—å—Å–Ω—ã–π</option>
            <option value="stripe" ${layer.noiseType === 'stripe' ? 'selected' : ''}>–ü–æ–ª–æ—Å–∞—Ç—ã–π</option>
            <option value="turbulent" ${layer.noiseType === 'turbulent' ? 'selected' : ''}>–¢—É—Ä–±—É–ª–µ–Ω—Ç–Ω—ã–π</option>
            <option value="multilayerPerlin" ${layer.noiseType === 'multilayerPerlin' ? 'selected' : ''}>–ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π –ü–µ—Ä–ª–∏–Ω</option>
            <option value="diamondSquare" ${layer.noiseType === 'diamondSquare' ? 'selected' : ''}>–ê–ª–º–∞–∑–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç</option>
            <option value="ridgedMultifractal" ${layer.noiseType === 'ridgedMultifractal' ? 'selected' : ''}>–†–∏–¥–∂–µ–¥ –ú—É–ª—å—Ç–∏—Ñ—Ä–∞–∫—Ç–∞–ª</option>
            <option value="midpointDisplacement" ${layer.noiseType === 'midpointDisplacement' ? 'selected' : ''}>–°–º–µ—â–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–π —Ç–æ—á–∫–∏</option>
            <option value="voronoiRidged" ${layer.noiseType === 'voronoiRidged' ? 'selected' : ''}>–í–æ—Ä–æ–Ω–æ–π –†–∏–¥–∂–µ–¥</option>
            <option value="wavelet" ${layer.noiseType === 'wavelet' ? 'selected' : ''}>–í–µ–π–≤–ª–µ—Ç</option>
            <option value="erosion" ${layer.noiseType === 'erosion' ? 'selected' : ''}>–≠—Ä–æ–∑–∏—è</option>
            <option value="flow" ${layer.noiseType === 'flow' ? 'selected' : ''}>–ü–æ—Ç–æ–∫–∏</option>
            <option value="organic" ${layer.noiseType === 'organic' ? 'selected' : ''}>–û—Ä–≥–∞–Ω–∏—á–µ—Å–∫–∏–π</option>
            <option value="cloud" ${layer.noiseType === 'cloud' ? 'selected' : ''}>–û–±–ª–∞–∫–∞</option>
            <option value="lava" ${layer.noiseType === 'lava' ? 'selected' : ''}>–õ–∞–≤–∞</option>
            <option value="fabric" ${layer.noiseType === 'fabric' ? 'selected' : ''}>–¢–∫–∞–Ω—å</option>
          </select>
            <span class="tooltip">–¢–∏–ø —à—É–º–∞ –¥–ª—è —Å–ª–æ—è</span>
          </div>
          <div class="control-group">
            <label>–í–ª–∏—è–Ω–∏–µ —Å–ª–æ—è</label>
            <input type="number" value="${layer.weight}" min="0" max="1" step="0.01" onchange="updateLayer(${layer.id}, 'weight', this.value)" />
            <span class="tooltip">–í–ª–∏—è–Ω–∏–µ —Å–ª–æ—è –Ω–∞ –∏—Ç–æ–≥–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (0‚Äì1)</span>
          </div>
          <div class="control-group">
            <label>–ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å</label>
            <input type="number" value="${layer.noiseLevel}" min="0" max="1" step="0.01" onchange="updateLayer(${layer.id}, 'noiseLevel', this.value)" />
            <span class="tooltip">–û–±—â–∞—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å —à—É–º–∞ —Å–ª–æ—è</span>
          </div>
          <div class="control-group">
            <label>–ú–∞—Å—à—Ç–∞–± —à—É–º–∞</label>
            <input type="number" value="${layer.noiseScale}" min="1" max="100" step="1" onchange="updateLayer(${layer.id}, 'noiseScale', this.value)" />
            <span class="tooltip">–†–∞–∑–º–µ—Ä –¥–µ—Ç–∞–ª–µ–π —à—É–º–∞</span>
          </div>
          <div class="control-group">
            <label>–¢–∏–ø —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è</label>
            <select onchange="updateLayer(${layer.id}, 'smoothType', this.value); updateSmoothInputAttributes(${layer.id}, this.value)">
              <option value="gaussian" ${layer.smoothType === 'gaussian' ? 'selected' : ''}>–ì–∞—É—Å—Å–æ–≤–æ</option>
              <option value="median" ${layer.smoothType === 'median' ? 'selected' : ''}>–ú–µ–¥–∏–∞–Ω–Ω–æ–µ</option>
              <option value="bilateral" ${layer.smoothType === 'bilateral' ? 'selected' : ''}>–ë–∏–ª–∞—Ç–µ—Ä–∞–ª—å–Ω–æ–µ</option>
              <option value="anisotropic" ${layer.smoothType === 'anisotropic' ? 'selected' : ''}>–ê–Ω–∏–∑–æ—Ç—Ä–æ–ø–Ω–æ–µ</option>
              <option value="nonlocal" ${layer.smoothType === 'nonlocal' ? 'selected' : ''}>–ù–µ–ª–æ–∫–∞–ª—å–Ω–æ–µ</option>
              <option value="mean" ${layer.smoothType === 'mean' ? 'selected' : ''}>–£—Å—Ä–µ–¥–Ω—è—é—â–µ–µ</option>
            </select>
            <span class="tooltip">–¢–∏–ø —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è –¥–ª—è —Å–ª–æ—è</span>
          </div>
          <div class="control-group">
            <label>–°–∏–ª–∞ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è</label>
            <input id="smoothValue-${layer.id}" type="number" value="${layer.smoothValue}" onchange="updateLayer(${layer.id}, 'smoothValue', this.value)" />
            <span class="tooltip">–†–∞–¥–∏—É—Å –∏–ª–∏ —Å–∏–ª–∞ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è</span>
          </div>
          <div class="control-group">
            <label>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—è—Ç–µ–Ω</label>
            <input type="number" value="${layer.spots}" min="0" max="100" step="1" onchange="updateLayer(${layer.id}, 'spots', this.value)" />
            <span class="tooltip">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—è—Ç–µ–Ω –¥–ª—è –º–∞—Å–∫–∏</span>
          </div>
          <div class="control-group">
            <label>–¶–≤–µ—Ç–Ω–æ–π —à—É–º</label>
            <input type="checkbox" ${layer.colorNoise ? 'checked' : ''} onchange="updateLayer(${layer.id}, 'colorNoise', this.checked)" />
            <span class="tooltip">–í–∫–ª—é—á–∏—Ç—å RGB-—à—É–º</span>
          </div>
          <div class="control-group">
            <label>–ê–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª</label>
            <input type="number" value="${layer.alphaLevel}" min="0" max="1" step="0.01" onchange="updateLayer(${layer.id}, 'alphaLevel', this.value)" />
            <span class="tooltip">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å —Å–ª–æ—è (0‚Äì1)</span>
          </div>
          <div class="control-group">
            <label>–£–¥–∞–ª–∏—Ç—å —Å–ª–æ–π</label>
            <button onclick="removeLayer(${layer.id})">–£–¥–∞–ª–∏—Ç—å</button>
            <span class="tooltip">–£–¥–∞–ª—è–µ—Ç —Å–ª–æ–π</span>
          </div>
        `;
        layerList.appendChild(div);
        updateSmoothInputAttributes(layer.id, layer.smoothType);
      });
    }

    function updateLayer(id, key, value) {
      const layer = layers.find(l => l.id === id);
      if (layer) {
        layer[key] = key === 'colorNoise' ? value : key === 'smoothType' ? value : +value || value;
        generateNoise();
        saveToHistory();
      }
    }

    function saveToHistory() {
      history = history.slice(0, historyIndex + 1);
      history.push({
        layers: JSON.parse(JSON.stringify(layers)),
        canvasData: ctx.getImageData(0, 0, canvas.width, canvas.height)
      });
      historyIndex++;
      if (history.length > 50) {
        history.shift();
        historyIndex--;
      }
    }

    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        const state = history[historyIndex];
        layers = JSON.parse(JSON.stringify(state.layers));
        ctx.putImageData(state.canvasData, 0, 0);
        updateLayerUI();
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        const state = history[historyIndex];
        layers = JSON.parse(JSON.stringify(state.layers));
        ctx.putImageData(state.canvasData, 0, 0);
        updateLayerUI();
      }
    }

    //  —Ñ—É–Ω–∫—Ü–∏—è generateNoise
    async function generateNoise(targetMetrics = { ssim: 50, ncc: 50 }) {
      if (isProcessing) return; // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –¥—É–±–ª–∏—Ä—É—é—â–∏–µ—Å—è –≤—ã–∑–æ–≤—ã
      if (!originalImageData) {
        alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π —à—É–º–∞.');
        return;
      }

      isProcessing = true;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      let attempts = 0;
      const maxAttempts = 3; // –£–º–µ–Ω—å—à–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
      let finalImageData = new ImageData(new Uint8ClampedArray(originalImageData.data), width, height);
      let metrics;
      const progressDiv = document.getElementById('progress');

      try {
        while (attempts < maxAttempts) {
          if (progressDiv) progressDiv.textContent = `–ò—Ç–µ—Ä–∞—Ü–∏—è: ${attempts + 1}`;

          // –°–æ–∑–¥–∞—ë–º –∫–æ–ø–∏—é originalImageData –¥–ª—è –∫–∞–∂–¥–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏
          finalImageData = new ImageData(new Uint8ClampedArray(originalImageData.data), width, height);

          const masks = useAnalysis ? await analyzeImage(originalImageData, width, height) : {
            edges: new Uint8ClampedArray(width * height).fill(1),
            objects: new Uint8ClampedArray(width * height).fill(1),
            background: new Uint8ClampedArray(width * height).fill(1)
          };

          for (let layer of layers) {
            const maskType = ['impulse', 'saltPepper', 'sparkle', 'warp'].includes(layer.noiseType) ? 'background' :
              ['organic', 'fabric', 'flow'].includes(layer.noiseType) ? 'objects' : 'edges';
            const maskData = new Uint8ClampedArray(masks[maskType]); // –ù–æ–≤–∞—è –∫–æ–ø–∏—è –º–∞—Å–∫–∏

            // –°–æ–∑–¥–∞—ë–º –∫–æ–ø–∏—é –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è warp
            const inputImageData = layer.noiseType === 'warp' ? new ImageData(new Uint8ClampedArray(finalImageData.data), width, height) : null;

            const chunkImageData = await new Promise((resolve, reject) => {
              noiseWorker.onmessage = function (e) {
                if (e.data.error) reject(new Error(e.data.error));
                else resolve(e.data.imgData);
              };
              // –ü–µ—Ä–µ–¥–∞—ë–º –Ω–æ–≤—ã–µ –∫–æ–ø–∏–∏ –±—É—Ñ–µ—Ä–æ–≤
              noiseWorker.postMessage({
                width,
                height,
                layer: {
                  ...layer,
                  noiseLevel: Math.min(1, layer.noiseLevel * (1 + attempts * 0.3)), // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å
                  weight: Math.min(1, layer.weight * (1 + attempts * 0.15)) // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –≤–µ—Å
                },
                spots: layer.spots || 20, // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø—è—Ç–Ω–∞ –¥–ª—è –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ—Å—Ç–∏
                colorPalette: document.getElementById('colorPalette').value,
                maskData: new Uint8ClampedArray(maskData), // –ù–æ–≤–∞—è –∫–æ–ø–∏—è
                imgData: inputImageData ? new ImageData(new Uint8ClampedArray(inputImageData.data), width, height) : null
              }, [
                maskData.buffer,
                inputImageData ? new Uint8ClampedArray(inputImageData.data).buffer : null
              ].filter(Boolean));
            });

            // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ü–∏–∫–ª –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
            const finalData = finalImageData.data;
            const chunkData = chunkImageData.data;
            for (let i = 0; i < finalData.length; i += 4) {
              const maskValue = maskData[Math.floor(i / 4)] || 1;
              const weight = layer.weight * maskValue;
              finalData[i] = Math.min(255, finalData[i] + chunkData[i] * weight);
              finalData[i + 1] = Math.min(255, finalData[i + 1] + chunkData[i + 1] * weight);
              finalData[i + 2] = Math.min(255, finalData[i + 2] + chunkData[i + 2] * weight);
              finalData[i + 3] = Math.min(255, finalData[i + 3] + chunkData[i + 3] * weight);
            }
          }

          metrics = calculateMetrics(finalImageData, width, height, originalImageData);
          if (metrics.ssim < targetMetrics.ssim && metrics.ncc < targetMetrics.ncc) {
            break;
          }
          // –†–∞–Ω–Ω–∏–π –≤—ã—Ö–æ–¥, –µ—Å–ª–∏ –º–µ—Ç—Ä–∏–∫–∏ –±–ª–∏–∑–∫–∏
          if (metrics.ssim < 55 && metrics.ncc < 55 && attempts >= 1) {
            break;
          }
          attempts++;
        }

        ctx.putImageData(finalImageData, 0, 0);
        metricsDiv.textContent = `SSIM: ${metrics.ssim.toFixed(2)}%, NCC: ${metrics.ncc.toFixed(2)}%, PSNR: ${metrics.psnr.toFixed(2)} dB, RMSE: ${metrics.rmse.toFixed(2)}, MAE: ${metrics.mae.toFixed(2)}, AE: ${metrics.ae.toFixed(2)}, Entropy: ${metrics.entropy.toFixed(2)}`;
        updateRecommendations(metrics, attempts);
        if (progressDiv) progressDiv.textContent = `–ì–æ—Ç–æ–≤–æ: ${attempts} –∏—Ç–µ—Ä–∞—Ü–∏–π`;
        saveToHistory();
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –≤ generateNoise:', error);
      } finally {
        isProcessing = false;
      }
    }

    function download(name = 'noise.png') {
      const link = document.createElement('a');
      link.download = name;
      link.href = canvas.toDataURL();
      link.click();
    }

    async function saveCopies() {
      const count = +copiesInput.value || 5;
      progress.style.display = 'block';
      for (let i = 0; i < count; i++) {
        await generateNoise();
        progress.textContent = `–û–±—Ä–∞–±–æ—Ç–∫–∞: ${Math.round((i + 1) / count * 100)}%`;
        await new Promise(resolve => setTimeout(resolve, 100));
        download(`noise${i + 1}.png`);
      }
      progress.style.display = 'none';
    }

    function saveSettings() {
      const settings = {
        width: document.getElementById('width').value,
        height: document.getElementById('height').value,
        layers,
        colorPalette: document.getElementById('colorPalette').value,
        copies: copiesInput.value
      };
      const presetName = prompt('–í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø—Ä–µ—Å–µ—Ç–∞:') || 'default';
      let presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      presets[presetName] = settings;
      localStorage.setItem('noisePresets', JSON.stringify(presets));
      alert('–ü—Ä–µ—Å–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω!');
    }

    function loadPresets() {
      const presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      const presetName = prompt('–í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø—Ä–µ—Å–µ—Ç–∞ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏:\n–î–æ—Å—Ç—É–ø–Ω—ã–µ: ' + Object.keys(presets).join(', '));
      if (presets[presetName]) {
        const settings = presets[presetName];
        document.getElementById('width').value = settings.width || 512;
        document.getElementById('height').value = settings.height || 1024;
        document.getElementById('colorPalette').value = settings.colorPalette || '#ffffff';
        layers = settings.layers || [{
          id: Date.now(),
          noiseType: 'perlin',
          weight: 0.2,
          noiseLevel: 0.7,
          noiseScale: 10,
          smoothType: 'gaussian',
          smoothValue: 0,
          spots: 10,
          colorNoise: false,
          alphaLevel: 1
        }];
        copiesInput.value = settings.copies || 5;
        copiesDisplay.textContent = settings.copies || 5;
        updateLayerUI();
        generateNoise();
      } else {
        alert('–ü—Ä–µ—Å–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω!');
      }
    }

    copiesInput.addEventListener('input', () => {
      copiesDisplay.textContent = copiesInput.value;
    });

    // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –¥–µ–±ouncer
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // –ü—Ä–∏–º–µ–Ω—è–µ–º –¥–µ–±ouncing –∫ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞–º –≤–≤–æ–¥–∞
    const inputs = document.querySelectorAll('input, select');
    inputs.forEach(input => {
      input.removeEventListener('input', generateNoise);
      input.addEventListener('input', debounce(generateNoise, 600)); // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∑–∞–¥–µ—Ä–∂–∫—É
    });

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø—Ä–µ—Å–µ—Ç–æ–≤
    document.querySelectorAll('.presetBtn').forEach(btn => {
      btn.removeEventListener('click', loadPreset);
      btn.addEventListener('click', debounce(loadPreset, 600));
    });

    window.addEventListener('resize', generateNoise);
    updateLayerUI();
    generateNoise();

    function openPresetModal() {
      document.getElementById("presetModal").style.display = "block";
      updatePresetList();
    }

    function closePresetModal() {
      document.getElementById("presetModal").style.display = "none";
    }

    document.getElementById("savePresetButton").addEventListener("click", function () {
      const nameInput = document.getElementById("presetNameInput");
      const presetName = nameInput.value.trim();
      if (!presetName) return;

      const settings = {
        width: document.getElementById('width').value,
        height: document.getElementById('height').value,
        layers,
        colorPalette: document.getElementById('colorPalette').value,
        copies: copiesInput.value
      };

      let presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      presets[presetName] = settings;
      localStorage.setItem('noisePresets', JSON.stringify(presets));

      nameInput.value = '';
      updatePresetList();
    });

    function loadPreset(presetName) {
      const presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      const settings = presets[presetName];
      if (!settings) return;

      document.getElementById('width').value = settings.width || 512;
      document.getElementById('height').value = settings.height || 1024;
      document.getElementById('colorPalette').value = settings.colorPalette || '#ffffff';
      layers = settings.layers || getDefaultLayers();
      copiesInput.value = settings.copies || 5;
      copiesDisplay.textContent = settings.copies || 5;

      updateLayerUI();
      generateNoise();
      closePresetModal();
    }

    function deletePreset(presetName) {
      if (!confirm(`–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ—Å–µ—Ç "${presetName}"? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ.`)) return;
      let presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      delete presets[presetName];
      localStorage.setItem('noisePresets', JSON.stringify(presets));
      updatePresetList();
    }

    function updatePresetList() {

      const listContainer = document.getElementById("presetList");
      listContainer.innerHTML = "";

      const presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');
      const sortedNames = Object.keys(presets).sort();

      sortedNames.forEach(name => {
        const card = document.createElement("div");
        card.className = "preset-card";

        const title = document.createElement("div");
        title.textContent = name;

        const loadBtn = document.createElement("button");
        loadBtn.textContent = "–ó–∞–≥—Ä—É–∑–∏—Ç—å";
        loadBtn.className = "load";
        loadBtn.onclick = () => loadPreset(name);

        const deleteBtn = document.createElement("button");
        deleteBtn.textContent = "–£–¥–∞–ª–∏—Ç—å";
        deleteBtn.className = "delete";
        deleteBtn.onclick = () => deletePreset(name);

        card.appendChild(title);
        card.appendChild(loadBtn);
        card.appendChild(deleteBtn);
        listContainer.appendChild(card);
      });
    }

    document.getElementById("closeModal").addEventListener("click", closePresetModal);
    document.getElementById("openPresetModalButton").addEventListener("click", openPresetModal);
    window.onclick = function (event) {
      if (event.target == document.getElementById("presetModal")) closePresetModal();
    };

    function getDefaultLayers() {
      return [{
        id: Date.now(),
        noiseType: 'perlin',
        weight: 0.2,
        noiseLevel: 0.7,
        noiseScale: 50,
        smoothType: 'gaussian',
        smoothValue: 0,
        spots: 10,
        colorNoise: false,
        alphaLevel: 1
      }];
    }

    let cvReady = false;
    function onOpenCvReady() {
      cvReady = true;
      console.log('OpenCV.js –≥–æ—Ç–æ–≤');
    }

    async function analyzeImage(imageData, width, height) {
      if (!cvReady) throw new Error('OpenCV.js –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω');

      const src = cv.matFromImageData(imageData);
      const gray = new cv.Mat();
      const edges = new cv.Mat();
      const objectMask = new cv.Mat();
      const backgroundMask = new cv.Mat();

      // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ –æ—Ç—Ç–µ–Ω–∫–∏ —Å–µ—Ä–æ–≥–æ
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

      // –î–µ—Ç–µ–∫—Ü–∏—è –∫—Ä–∞–µ–≤ (Canny)
      cv.Canny(gray, edges, 50, 150);

      // –°–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è –æ–±—ä–µ–∫—Ç–æ–≤ (–∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π –ø–æ—Ä–æ–≥)
      cv.adaptiveThreshold(gray, objectMask, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);

      // –ò–Ω–≤–µ—Ä—Å–∏—è –¥–ª—è —Ñ–æ–Ω–∞
      cv.bitwise_not(objectMask, backgroundMask);

      // –°–æ–∑–¥–∞–µ–º –º–∞—Å–∫–∏ –¥–ª—è Web Worker
      const masks = {
        edges: new Uint8ClampedArray(width * height),
        objects: new Uint8ClampedArray(width * height),
        background: new Uint8ClampedArray(width * height)
      };

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          masks.edges[idx] = edges.data[idx] > 128 ? 0.2 : 1.0; // –ú–µ–Ω—å—à–∏–π –≤–µ—Å –¥–ª—è –∫—Ä–∞–µ–≤
          masks.objects[idx] = objectMask.data[idx] > 128 ? 0.3 : 1.0; // –ú–µ–Ω—å—à–∏–π –≤–µ—Å –¥–ª—è –æ–±—ä–µ–∫—Ç–æ–≤
          masks.background[idx] = backgroundMask.data[idx] > 128 ? 1.0 : 0.5; // –ü–æ–ª–Ω—ã–π –≤–µ—Å –¥–ª—è —Ñ–æ–Ω–∞
        }
      }

      src.delete();
      gray.delete();
      edges.delete();
      objectMask.delete();
      backgroundMask.delete();

      return masks;
    }


    // –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    document.getElementById('imageUpload').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const img = new Image();
      img.src = URL.createObjectURL(file);
      await new Promise((resolve) => (img.onload = resolve));

      // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      if (img.width > 1024 || img.height > 1024) {
        width = Math.min(1024, img.width);
        height = Math.round(img.height * (width / img.width));
      } else {
        width = img.width;
        height = img.height;
      }

      resizeCanvas(width, height);
      ctx.drawImage(img, 0, 0, width, height);
      originalImageData = ctx.getImageData(0, 0, width, height);
      document.getElementById('width').value = width;
      document.getElementById('height').value = height;

      await generateNoise();
    });

    // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ resize
    window.addEventListener('resize', debounce(() => {
      const now = Date.now();
      if (now - lastResize < 600) return; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —á–∞—Å—Ç—ã–µ –≤—ã–∑–æ–≤—ã
      lastResize = now;

      if (originalImageData) {
        resizeCanvas(width, height);
        ctx.putImageData(originalImageData, 0, 0);
      }
    }, 600));

    function toggleAnalysis() {
      useAnalysis = !useAnalysis;
      if (originalImageData) generateNoise();
    }

    async function initializePresets() {
      if (!confirm(`–í—ã —Ç–æ—á–Ω–æ —Ö–æ—Ç–∏–µ –≤–µ—Ä–Ω—É—Ç—å –±–∞–∑–æ–≤—ã–µ –ø—Ä–µ—Å–µ—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ —É–¥–∞–ª–∏–ª–∏ —Ä–∞–Ω–µ–µ?`)) return;

      // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø—Ä–µ—Å–µ—Ç—ã –∏–∑ JSON —Ñ–∞–π–ª–∞
      const response = await fetch('initializePresets.js');
      const defaultPresets = await response.json();

      // –ü–æ–ª—É—á–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø—Ä–µ—Å–µ—Ç—ã –∏–∑ localStorage –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –ø—É—Å—Ç–æ–π –æ–±—ä–µ–∫—Ç
      let presets = JSON.parse(localStorage.getItem('noisePresets') || '{}');

      // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–µ—Å–µ—Ç—ã –∏–∑ JSON –≤ –æ–±—ä–µ–∫—Ç presets
      defaultPresets.forEach(preset => {
        presets[preset.name] = preset;
      });

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –ø—Ä–µ—Å–µ—Ç—ã –≤ localStorage
      localStorage.setItem('noisePresets', JSON.stringify(presets));

      // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –ø—Ä–µ—Å–µ—Ç–æ–≤
      updatePresetList();

    }
  

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    updateLayerUI();
  </script>
</body>

</html>
